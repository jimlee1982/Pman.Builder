{
    "id": "roo-file-38",
    "name": "Pman.Tab.BuilderTree",
    "parent": "Pman.Tab.BuilderTab",
    "title": "Pman.Tab.BuilderTree",
    "path": "/home/alan/gitlive/Pman.Builder/Pman.Tab.BuilderTree.bjs",
    "items": [
        {
            "region": "west",
            "xtype": "NestedLayoutPanel",
            "|xns": "Roo",
            "items": [
                {
                    "|xns": "Roo",
                    "xtype": "BorderLayout",
                    "*prop": "layout",
                    "items": [
                        {
                            "|xns": "Roo",
                            "xtype": "LayoutRegion",
                            "*prop": "center"
                        },
                        {
                            "*prop": "south",
                            "height": 300,
                            "split": true,
                            "xtype": "LayoutRegion",
                            "|xns": "Roo"
                        },
                        {
                            "listeners": {
                                "activate": "function (_self)\n{\n    \n    _this.tree = _self.tree;\n    if (_this.hasMouseEvent) {\n        return;\n    }\n    \n    _this.hasMouseEvent = true;\n     this.el.on('mouseover', function() { _this.isMouseOver= true; });\n    this.el.on('mouseout', function() { _this.isMouseOver = false; });\n\n}"
                            },
                            "region": "center",
                            "xtype": "TreePanel",
                            "|xns": "Roo",
                            "items": [
                                {
                                    "listeners": {
                                        "beforenodedrop": "function (e)\n{\n    // nodedragover handles the allow/disallow..\n    \n    /*\n    tree - The TreePanel\n    target - The node being targeted for the drop\n    data - The drag data from the drag source\n    point - The point of the drop - append, above or below\n    source - The drag source\n    rawEvent - Raw mouse event\n    dropNode - Drop node(s) provided by the source OR you can supply node(s) to be inserted by setting them on this object.\n    cancel - Set this to true to cancel the drop.\n    */\n    var np = e.point == 'append' ? e.target : e.parent.target ; // new parent\n      \n    if (!e.tree || !e.dropNode) {\n    \n        // form palete...\n        \n    \n    \n    \n    \n    \n        console.log('no tree or dropNode');\n        return; // fixme drop of elements from palete..\n    }\n\n    // always drop onto own parent\n    if (np == e.dropNode.parentNode) {\n        if (e.rawEvent.ctrlKey) {\n            e.dropNode = _this.dupeNode(e.dropNode);\n        }\n        return true;\n    }\n    // can append has to use palete...\n    // this code should be in nodedragover.\n    \n   if (_this.canAppend(np, e.dropNode.elConfig)) {\n        if (e.rawEvent.ctrlKey) {\n            e.dropNode = _this.dupeNode(e.dropNode);\n              \n            if (np.elConfig.xtype == 'GridEditor') {\n                e.dropNode.elConfig['*prop'] = 'field';\n            }\n            \n        }\n        return true;\n    }  \n    console.log('can not drop ' + e.dropNode.elConfig.xtype + ' ontop of ' + np.elConfig.xtype);\n    \n    \n    \n    return false;\n                        \n\n}",
                                        "nodedrop": "function (e)\n{\n    \n    Roo.log(\"Node Drop\");\n    return;\n    e.dropNode.setText(\n        _this.configToText(e.dropNode.elConfig)\n        );\n        var bp = Pman.Tab.BuilderPanel;\n        bp.redraw.defer(1000, bp, [true]);\n\n}",
                                        "click": "function (node, e)\n{\n      e.preventDefault();\n                       // console.log(e.button);\n        this.setCurrentNode(node);\n\n}",
                                        "contextmenu": "function (node, e)\n{\n    e.stopEvent();\n        \n        this.getSelectionModel().select(node);\n         _this.setCurrentNode(node);\n        var xt = node.elConfig.xtype;\n        var altx= false;\n        if (typeof(node.elConfig['*prop']) != 'undefined') {\n            altx = node.parentNode.elConfig.xtype +'.' + node.elConfig['*prop'];\n        }\n        var mn = Pman.Tab.BuilderPalete.getMenu(xt,altx);\n        \n        \n        if (mn) {\n            mn.show(e.getTarget());\n        }\n        \n\n\n}",
                                        "nodedragover": "function (e)\n{\n    Roo.log('nodedragover');\n     Roo.log(e);\n     // e.cancel..\n     // if we have within the same tree:\n       // dropNode (the node being dragged !!important!!) \n       // point: below, append\n       // target - node \n    // for palete\n        // dropNode = false;\n        // grid = the grid...\n        // source.dragData.selections[..] \n   \n    \n    // we can only check parents... (we in theory can check dupe properties.. but let's ignore that for the time being.)\n    \n    // ok off we go.\n    \n    if (!e.dropNode) {\n        // drag from palete..\n        if (!e.source.dragData.selections.length) {\n            e.cancel = true;\n            return;\n        }\n        var drop_rec = e.source.dragData.selections[0];\n        var drop_xtype = drop_rec.data.name;\n        var ok_parents = drop_rec.json.parents;\n        Roo.log(\"TEST PARENTS: \" + ok_parents.join(', '));\n        var new_parent = this.nodeXtype((e.point == 'append') ? e.target :  e.target.parentNode);\n        Roo.log(\"NEW PARENT: \" + e.point + \" = \" + new_parent);\n        \n        // see if the new_parent is actually in the list of ok_parents\n        e.cancel = true;\n        Roo.each(ok_parents,function(n) {\n            if (n == new_parent || n.split(':').shift() == new_parent) {\n                e.cancel = false;\n                return true;\n            }\n        });\n        // done all the checks...\n        return;\n        \n    }\n     \n   \n}   \n    ",
                                        "dragdrop": "function (_self, node, dd, e)\n{\n    Roo.log(\"Drag Drop\");\n    Roo.log(e);\n}"
                                    },
                                    "*prop": "tree",
                                    "animate": false,
                                    "containerScroll": true,
                                    "ddGroup": "component",
                                    "enableDD": true,
                                    "rootVisible": true,
                                    "xtype": "TreePanel",
                                    "|dupeNode": " function(node)\n    {\n        var cfg = this.cloneConfig(node.elConfig);\n        \n        var newNode = new Roo.tree.TreeNode(\n        {\n                id: Roo.id(),\n                text: this.configToText(cfg)\n        });\n        \n        newNode.elConfig = cfg;\n        node.eachChild(function(n) {\n            newNode.appendChild(this.dupeNode(n));\n        },this);\n        \n        return newNode;\n            \n    }",
                                    "|appendNode": "function(parent, inConfig, markUndo) {\n    \n        \n \n    var items = [];\n    if (inConfig.items) { // loading!\n        items = inConfig.items;\n        delete inConfig.items;\n    }\n    var config = this.cloneConfig(inConfig);\n    \n    if (!parent) {\n\tparent = this.root;\n    }\n        \n        \n    //var canAppend = this.canAppend(parent,config);\n    //if (canAppend !== true) {\n    //    console.log(\"Unable to add element \" + canAppend);\n    //\tRoo.Msg.alert(\"Unable to add element\", canAppend);\n    //\t\treturn false;\n   //\t\t}\n         \n    var newNode = new Roo.tree.TreeNode({\n            text: this.configToText(config)\n    });\n            \n    \n    newNode.elConfig = config;\n    //if (markUndo === true) {\n    //Pman.Tab.Builder.markUndo(\"Add \" + newNode.text);\n    //\n        // appends to our tree...\n    parent.appendChild(newNode);\n    \n        \n    if (items.length) {\n        Roo.each(items, function(i) {\n            this.appendNode(newNode, i);\n        },this);\n        \n    }\n        \n        \n        /*\n        -- panels with panes...\n\t\tif (items && items.length) {\n\t\t\tfor (var i = 0; i < items.length; i++) {\n\t\t\t\t\tthis.appendConfig(items[i], newNode, false);\n\t\t\t}\n\t\t}\n\t\tif (opts.doUpdate !== false) {\n\t\t\tthis.updateForm(false, newNode);\n\t\t}\n        */\n    return newNode;\n\n\t \n}\n",
                                    "|clearAll": "function() {\n    var rt = this.root;\n     if (rt.childNodes.length) {\n        rt.removeChild(rt.childNodes[0]);\n    }\n   \n    this.root.elConfig  = Roo.apply({ }, this.defaultElConfig());  \n    //var btop = Pman.Tab.BuilderTop;\n    //if (btop.modsel && btop.modsel.lastData) {\n    //    this.tree.root.elConfig.app = btop.modsel.lastData.app;\n    //}\n    \n    this.setCurrentNode(this.root,true);\n\n}\n",
                                    "|cloneConfig": "function(config) {\n    if (!config) { return null; }\n    var newConfig = {};\n    \n    for (var i in config) {\n        if (typeof config[i] == 'object') {\n             newConfig[i] = this.cloneConfig(config[i]);\n        } else if (typeof config[i] != 'function') { // should this happen?\n             newConfig[i] = config[i];\n        }\n    }\n    return newConfig;\n}\n",
                                    "|configToText": "function(c) {\n     \n\tvar txt = [];\n\tc = c || {};\n          var sr = (typeof(c['+buildershow']) != 'undefined') &&  !c['+buildershow'] ? true : false;\n        if (sr) txt.push('<s>');\n        if (typeof(c['*prop']) != 'undefined')   { txt.push(c['*prop']+ ':'); }\n\tif (c.xtype)      { txt.push(c.xtype); }\n\tif (c.fieldLabel) { txt.push('[' + c.fieldLabel + ']'); }\n\tif (c.boxLabel)   { txt.push('[' + c.boxLabel + ']'); }\n    \n    \n\tif (c.layout)     { txt.push('<i>' + c.layout + '</i>'); }\n\tif (c.title)      { txt.push('<b>' + c.title + '</b>'); }\n        if (c.header)    { txt.push('<b>' + c.header + '</b>'); }\n        if (c.legend)      { txt.push('<b>' + c.legend + '</b>'); }\n\tif (c.text)       { txt.push('<b>' + c.text + '</b>'); }\n        if (c.name)       { txt.push('<b>' + c.name+ '</b>'); }\n\tif (c.region)     { txt.push('<i>(' + c.region + ')</i>'); }\n        if (c.dataIndex) { txt.push('[' + c.dataIndex+ ']'); }\n        if (sr) txt.push('</s>');\n\treturn (txt.length == 0 ? \"Element\" : txt.join(\" \"));\n \n  \n}\n",
                                    "|currentNodeType": "function() {\n    return this.nodeXtype(this.currentNode);\n \n}\n",
                                    "|defaultElConfig": "function() {\n    return {\n       xtype : '*Module',\n        \n        module : 'TestApp',\n        part:   'Partname',\n        modkey : 0,\n        region : 'center',\n        parent : 'Pman',\n        name : 'Module Name',\n        items: [] \n    };\n}\n",
                                    "|loadBJS": "function(module, part) {\n    var _t = this;\n    new Pman.Request({\n        url : baseURL + '/Roo/Builder_part.php',\n        method : 'GET',\n        params : {\n           _id : part\n        },\n        success : function(res)         \n        {\n            // data is in.. \n            Roo.log(res);\n            _t.loadTree(JSON.parse(res.data.json));\n            \n         \n        },\n\n     })  \n        \n    \n    \n}\n",
                                    "|loadTree": "function(o) {\n    this.clearAll();\n    this.root.elConfig = o;\n    this.root.setText(this.configToText(this.root.elConfig));\n    this.appendNode(this.root, o.items[0]);\n    this.root.expand(true);\n    Pman.Tab.BuilderView.panel.redraw();\n    this.setCurrentNode(this.root,true);\n}\n",
                                    "|nodeXtype": "function(n) {\n     if (!n) {return ''; }\n    var xt = n.elConfig.xtype ||  '';\n    var xns= n.elConfig['|xns'] ||   '';\n    xns += xns.length ? '.' : '';\n    return xns + xt;\n}\n",
                                    "|renderer": "function(n) { return n.text; }",
                                    "|setCurrentNode": "function(node,select) {\n        this.currentNode = node || this.root;\n        \n        //Pman.Tab.BuilderView.highlightElement(this.currentNode);\n\n        var p = Pman.Tab.BuilderProps.grid;\n        if (p) { //may not be ready yet..\n            p.setCurrrentNode(this.currentNode);\n        }\n        \n      \n        this.currentNode.setText(this.configToText(this.currentNode.elConfig));\n        \n        if (select) { //&& node !== this.tree.root) {\n            if (this.currentNode !== this.root)  {\n                     this.currentNode.ensureVisible();\n              }   \n             this.currentNode.expand(false,false);\n            this.currentNode.select();\n\t}\n\t// update palete..\n\tPman.Tab.BuilderPalette.grid.getSelectionModel().clearSelections();\n\tPman.Tab.BuilderPalette.grid.view.refresh();\n\n}\n",
                                    "|xns": "Roo.tree",
                                    "items": [
                                        {
                                            "|xns": "Roo.tree",
                                            "xtype": "DefaultSelectionModel",
                                            "*prop": "sm"
                                        },
                                        {
                                            "*prop": "root",
                                            "text": "Part",
                                            "xtype": "TreeNode",
                                            "|elConfig": "function() {\n    return  {\n         xtype : '*Module',\n            \n            app : 'TestApp',\n            // perm\n            // permtype\n            modkey : 0,\n            '|module' :  '',\n            region : 'center',\n            '|parent' : 'Pman',\n            name : \"Module Name\",\n            items: [] \n\n    \n    }\n}\n",
                                            "|xns": "Roo.tree"
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ],
    "permname": "",
    "modOrder": "001"
}